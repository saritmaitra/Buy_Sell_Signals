# -*- coding: utf-8 -*-
"""buy &  sell strategy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pAWoooyCW-jeewA-AT3twyXIdLCdEaaQ
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
from pandas import DataFrame 
import seaborn as sns
from pylab import rcParams
import matplotlib.pyplot as plt
from matplotlib import rc
from pandas.plotting import register_matplotlib_converters
import pandas_datareader as web
!pip install plotly
import plotly.graph_objects as go

# %matplotlib inline
# %config InlineBackend.figure_format='retina'

register_matplotlib_converters()
sns.set(style='whitegrid', palette='muted', font_scale=1.5)

rcParams['figure.figsize'] = 22, 10

RANDOM_SEED = 42

np.random.seed(RANDOM_SEED)
from scipy import stats
from sklearn.preprocessing import MinMaxScaler

print("....Data Loading...."); print();
print('\033[4mCrude Oil Spot Price\033[0m');
data = web.DataReader('CL=F', data_source = 'yahoo', start = '2000-01-01')
data

!pip install cufflinks
import cufflinks as cf
from plotly.offline import iplot, init_notebook_mode
init_notebook_mode()

pip install chart_studio

qf = cf.QuantFig(data, title="Crude Oil's Stock Price",legend='top', name='CrudeOil')
qf.add_volume()
qf.add_sma(periods=20, column='Close', color='red')
qf.add_ema(periods=20, color='green')
qf.iplot()

df = data[['Close']]

# Plot the closing price 
df.Close.plot(figsize=(10, 5))
plt.ylabel("Prices (USD)")
plt.title("Crude Oil Price Series")
plt.show()

df.loc[:,'ema10'] = (df.loc[:,'Close'].ewm(span=10,adjust=True,ignore_na=True).mean())
df.loc[:,'ema20'] = (df.loc[:,'Close'].ewm(span=20,adjust=True,ignore_na=True).mean())


df.loc[:, 'price_tomorrow'] = df.loc[:,'Close'].shift(-1)

df.dropna(inplace=True)
X = np.array(df[['ema10', 'ema20']])

# Define dependent variable
y = np.array(df['price_tomorrow'])

fig = go.Figure(data=[go.Candlestick(x=data.index[-100:],
                                     open=data['Open'][-100:],
                                     high=data['High'][-100:],
                                     low=data['Low'][-100:],
                                     close=data['Close'][-100:])])
fig.add_trace(go.Scatter(x = df.index[-100:], y = df.ema10[-100:], marker = dict(
        color = "blue"), name = "EMA10"))
fig.add_trace(go.Scatter(x = df.index[-100:], y = df.ema20[-100:], marker = dict(
        color = "gray"), name = "EMA10"))
fig.update_xaxes(showline=True, linewidth=2, linecolor='black', mirror=True)
fig.update_yaxes(showline=True, linewidth=2, linecolor='black', mirror=True)
fig.update_layout(autosize = False, width = 1200, height = 600,)
fig.update_layout(title='Candlestick plot::Crude oil prices', yaxis_title='(US$)')
fig.show()

from sklearn.model_selection import TimeSeriesSplit

tscv = TimeSeriesSplit()
#print(tscv)
TimeSeriesSplit(max_train_size = 0.80, n_splits=5)
for train_index, test_index in tscv.split(X):
  #print("TRAIN:", train_index, "TEST:", test_index)
  X_train, X_test = X[train_index], X[test_index]
  y_train, y_test = y[train_index], y[test_index]

print('Length train set: {}'.format(len(y_train)))
print('Length test set: {}'.format(len(y_test)))

from sklearn.linear_model import LinearRegression, ElasticNet

# Create a linear regression model
model = ElasticNet(max_iter=5000, random_state=0).fit(X_train, y_train)
print("Linear Regression model:")
print("Crude oil Price (y) = %.2f * 10 Days Moving Average (x1) \
+ %.2f * 20 Days Moving Average (x2) \
+ %.2f (constant)" % (model.coef_[0], model.coef_[1], model.intercept_))

y_pred = DataFrame(model.predict(X_test), index = df[-len(y_test):].index, columns = ['price'])
y_test = DataFrame(y_test, index = df[-len(y_test):].index, columns = ['price'])

fig = go.Figure()
fig.add_trace(go.Scatter(x = y_pred.index, y = y_pred.price,
                         marker = dict(color ="red"), name = "Actual price"))
fig.add_trace(go.Scatter(x = y_test.index, y = y_test.price, marker=dict(
        color = "green"), name = "Predicted price"))

fig.update_xaxes(showline = True, linewidth = 2, linecolor='black', mirror = True, showspikes = True,)
fig.update_yaxes(showline = True, linewidth = 2, linecolor='black', mirror = True, showspikes = True,)
fig.update_layout(
    title= "Crude oil price (predicted vs actual", 
    yaxis_title = 'price (US$)',
    hovermode = "x",
    hoverdistance = 100, # Distance to show hover label of data point
    spikedistance = 1000) 
fig.update_layout(autosize = False, width = 1000, height = 400,)
fig.show()

accuracy = model.score(X_test, y_test)
print("Accuracy: ", round(accuracy*100,2).astype(str) + '%')

oil = DataFrame()

oil['price'] = df[-len(y_test):]['Close']
oil['pred_next_day'] = y_pred
oil['actual_price_next_day'] = y_test
oil['returns'] = oil['price'].pct_change().shift(-1)
oil['signal'] = np.where(oil.pred_next_day.shift(1) < oil.pred_next_day,1,0)
oil['strategy_returns'] = oil.signal * oil['returns']
((oil['strategy_returns']+1).cumprod()).plot(figsize=(10,5))
plt.ylabel('Cumulative Returns')
plt.show()

'Sharpe Ratio %.2f' % (oil['strategy_returns'].mean()/oil['strategy_returns'].std()*(252**0.5))

df.loc[:,'pred_price'] = model.predict(df[['ema10', 'ema20']])
df.loc[:,'signal'] = np.where(df.pred_price.shift(1) < df.pred_price,"Buy","Sell")
df.loc[:,'price_direction'] = df['signal'].replace(('Sell', 'Buy'), (0, 1))
df.tail()

buys = df.loc[df['price_direction'] == 1]
sells = df.loc[df['price_direction'] == 0]

# Plot 
fig = plt.figure(figsize=(20, 5))
plt.plot(df.index, df['Close'], lw=2., label='Price')

# Plot the buy and sell signals on the same plot
plt.plot(buys.index, df.loc[buys.index]['Close'], 
         '^', markersize=5, color='k', lw=2., label='Buy')
plt.plot(sells.index, df.loc[sells.index]['Close'], 
         'v', markersize=5, color='g', lw=2., label='Sell')
plt.ylabel('Price (USD)')
plt.xlabel('Date')
plt.title('Buy and Sell signals plot')
plt.legend(loc='best')

# Display everything
plt.show()

print('Data shape:', df.shape); print();
X = np.array(df[['ema10', 'ema20']])

# Define dependent variable
y = np.array(df['price_direction'])

tscv = TimeSeriesSplit()
#print(tscv)
TimeSeriesSplit(max_train_size = 0.80, n_splits=5)
for train_index, test_index in tscv.split(X):
  #print("TRAIN:", train_index, "TEST:", test_index)
  X_train, X_test = X[train_index], X[test_index]
  y_train, y_test = y[train_index], y[test_index]

print('Length train set: {}'.format(len(y_train)))
print('Length test set: {}'.format(len(y_test)))

# Use Cross-validation/backtesting.
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_val_score, KFold
from sklearn.metrics import accuracy_score
from numpy import mean
from numpy import std


print('\033[4mLogistic Regression\033[0m')
model_clf = LogisticRegression(solver='liblinear', C=0.05, random_state=0).fit (X_train,y_train)

model_scores = cross_val_score(model_clf, X_train, y_train, cv=5);
model_mean = model_scores.mean();
print ('Accuracy score (%):', model_mean*100);

y_pred = model_clf.predict(X_test)
# evaluate predictions
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy: %.2f%%" % (accuracy * 100.0))

# Run the code to view the classification report metrics
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report 
print('Confusion matrix:')
print(confusion_matrix(y_test, y_pred)); print();
print ('Classification report:')
print (classification_report(y_test, y_pred))

from sklearn.metrics import precision_score

print("Precision score: {}".format(precision_score(y_test,y_pred)))

print('\033[4mProbability of prediction results\033[0m')
predict_prob = model.predict_proba(X_test)
predict_prob = DataFrame(predict_prob)
print(predict_prob.tail(10))